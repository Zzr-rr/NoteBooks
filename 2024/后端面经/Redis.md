## Redis为什么适合计数的场景

Redis处理命令是单线程的，所以执行命令的过程是原子的。因此String数据类型适合技术场景。



## Redis如何实现分布式锁

Redis分布式锁的实现主要依赖于指令`SETNX`，执行该指令有两种情况。

- 如果key不存在，则插入。
- 如果key存在，则返回0。

通过这样的操作来进行加锁，一般来说，分布式锁会加上过期时间，以防止锁失效。

```redis
SET lock_key unique_value NX PX 10000
```

**解锁**的过程就是删除lock_key，但是不能乱删。要保证执行操作的客户端就是有锁的客户端，即判断客户端的unique_value是否与`GET lock_key`返回的值相同。

那么解锁的过程就可以被分为两个操作，一是判断客户端是否持有锁，二是删除锁。因此就需要保证原子性，而Redis执行Lua脚本的时候，可以以**原子性**的方式进行，保证了锁释放操作的**原子性**。



## 为什么Lua脚本能够保证原子性

> Blocking semantics that ensure the script's atomic execution.

当执行脚本时，所有的服务器活动在脚本的执行期间都会被阻塞。



## 如何实现消息队列？消息队列需要保证什么特性？

消息队列的特性是：1、保序性，首先得保证消息的顺序是能够得到保障的。2、可靠性，要保证消息不会丢失。3、去重性，要保证消息不会被重复处理。

**保序性**可以用队列这样的数据结构来实现，一端进，一端出。如果是List，使用LPUSH来存取消息，通过RPOP来读取消息，这样处理有一定的问题，就是消息处理者要时刻确保队列中没有消息，需要不停的RPOP，这样会使得CPU空转，对CPU有不必要的消耗。因此Redis为了解决这样一个问题，提供了BRPOP这样的命令，即阻塞式读取。

**可靠性**，即消息不能丢失，最简单想到的就是备份了，通过RPOPLPUSH来将消息push到另外一个队列中进行备份。

**去重性**，事件在保存的时候需要存入**唯一标识符**（或者叫全局ID）。



## 什么是消费组

一条消息的消费对象可能不只一个消费者，那么多个消费者都可以组成一个消费组。List是不支持消费组的实现的，而Stream支持。



## HyperLogLog有什么作用？其底层是如何是实现的？

HyperLogLog是一种用于统计基数的数据结构，即统计集合中不重复的元素的个数，标准误算率是0.81%。每个HyperLogLog大概仅需要消耗12KB内存，就可以实现对$2^{64}$个不同元素的基数统计。

HyperLogLog的底层基于概率实现，