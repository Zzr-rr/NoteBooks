## JMM如何抽象了Java的线程和主内存之间的关系？

在jdk1.2之前，这种区分不是非常明显，JMM通过与主内存（即共享内存）之间的数据读取来为线程提供内存空间，现成的静态变量，常量，方法区等都存储在主内存中。

在jdk1.2之后，JMM为线程创建了本地内存区，用于单独存放线程的方法栈，变量，常量等线程独有的信息，同时线程之间也可以通过主内存（即共享内存）来完成数据的共享。



### 追问1：什么是主内存？什么是本地内存？

主内存：所有线程创建的对象的实例、变量、常量等都是放在主内存中，为了更好的性能，虚拟机在创建这些变量的时候可能会优先存储在寄存器和高速缓冲器中。

本地内存：每个线程都由一个私有的本地内存，本地内存存储了该线程以读/写共享变量的副本。每个线程只能操作自己本地内存中的变量，如果需要对本地内存外的变量进行操作，需要通过主内存来进行。



## Java内存区域和JMM有何区别？

首先明确的是Java内存区域和JMM是完全两个不同的概念。

JVM内存结构和Java虚拟机运行时区域相关，就比如说堆主要用于存放对象实例。

JMM模型是一个抽象的概念，它更多的是为了简化Java多线程编程。比如说共享变量必须存储在主内存中。



## 讲一讲指令重排序以及它可能存在的问题

指令重排序指的是CPU为了提高指令执行的效率，会对指令进行重排序，指令重排序能够保证串行语义一致，但是没有义务保证多线程间的语义也一致，所以在多线程下，指令重排序可能会引发一些问题。



## 简单介绍一下JVM

JVM就是Java virtual Machine，就是java虚拟机。





## JVM的GC主要作用对象是谁？

主要是发生在堆区域，几乎所有的实例对象都会存储在堆区域。垃圾回收主要操作对象就是堆。很多垃圾收集算法会分代进行回收，因此堆区域也可以分为新生代，老年代和永久代（JDK 7之前，后被MetaSpace替代）。

