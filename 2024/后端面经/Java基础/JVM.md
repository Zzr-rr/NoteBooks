## JMM如何抽象了Java的线程和主内存之间的关系？

在jdk1.2之前，这种区分不是非常明显，JMM通过与主内存（即共享内存）之间的数据读取来为线程提供内存空间，现成的静态变量，常量，方法区等都存储在主内存中。

在jdk1.2之后，JMM为线程创建了本地内存区，用于单独存放线程的方法栈，变量，常量等线程独有的信息，同时线程之间也可以通过主内存（即共享内存）来完成数据的共享。



### 追问1：什么是主内存？什么是本地内存？

主内存：所有线程创建的对象的实例、变量、常量等都是放在主内存中，为了更好的性能，虚拟机在创建这些变量的时候可能会优先存储在寄存器和高速缓冲器中。

本地内存：每个线程都由一个私有的本地内存，本地内存存储了该线程以读/写共享变量的副本。每个线程只能操作自己本地内存中的变量，如果需要对本地内存外的变量进行操作，需要通过主内存来进行。



## Java内存区域和JMM有何区别？

首先明确的是Java内存区域和JMM是完全两个不同的概念。

JVM内存结构和Java虚拟机运行时区域相关，就比如说堆主要用于存放对象实例。

JMM模型是一个抽象的概念，它更多的是为了简化Java多线程编程。比如说共享变量必须存储在主内存中。



## 讲一讲指令重排序以及它可能存在的问题

指令重排序指的是CPU为了提高指令执行的效率，会对指令进行重排序，指令重排序能够保证串行语义一致，但是没有义务保证多线程间的语义也一致，所以在多线程下，指令重排序可能会引发一些问题。



## 简单介绍一下JVM

JVM就是Java virtual Machine，就是java虚拟机。





## JVM的GC主要作用对象是谁？

主要是发生在堆区域，几乎所有的实例对象都会存储在堆区域。垃圾回收主要操作对象就是堆。很多垃圾收集算法会分代进行回收，因此堆区域也可以分为新生代，老年代和永久代（JDK 7之前，后被MetaSpace替代）。





## 介绍一下垃圾回收器

垃圾回收器就是用来回收内存中已被判定无用的垃圾对象。

垃圾回收器就是垃圾回收算法的相应实现。

它主要完成三件事：

1. 分配内存：垃圾回收算法的设计往往决定了内存模型和内存分配的方式。
2. 确保存活对象不会受到垃圾回收的影响。
3. 回收垃圾对象。

**常见的垃圾回收器**有：Serial（串行收集器）、ParNew（Serial的多线程版本）、Parallel Scavenge（并行多线程回收器）、Serial Old（Serial的老年代版本）、Parallel Old（PS收集器的老年代版本）、CMS（concurrent mark sweep）、G1（CMS的加强版）。

**Serial**

串行垃圾回收器，回收时触发”Stop The World“来暂停线程的所有操作，来进行垃圾回收。

**ParNew**

Serial的多线程版本。新生代采用标记-复制算法，老年代采用标记-整理算法。

**Parallel Scavenge**

```
-XX:+UseParallelGC
    使用 Parallel 收集器+ 老年代串行
-XX:+UseParallelOldGC
    使用 Parallel 收集器+ 老年代并行
```

**Serial Old**

Serial收集器的老年代版本，一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。

**Parallel Old**

Parallel Scavenge的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量和CPU资源的场景可以使用。

**CMS**

CMS的出现是为了获得最短停顿时间，即注重用户体验的垃圾回收器。

Concurrent mark sweep，并发垃圾回收器，JDK1.4的时候出现的，不停止，一般建议升级为G1垃圾收集器。

主要分为以下几步：初始标记，并发标记，重新标记，并发清除。

对CPU资源敏感，无法处理**浮动垃圾**，它使用的**回收-清除**算法会导致收集结束时会有大量的空间碎片产生。

**G1收集器**

G1收集器大概分为以下几个步骤：初始标记、并发标记、最终标记、筛选回收。

G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，允许选择回收价值最大的Region。

**ZGC收集器**

标记-复制算法。Java21中引入了分代ZGC。



### 介绍一下垃圾回收算法

标记-清除算法、复制算法、标记-整理算法和分代收集算法四种垃圾回收算法。

**标记-清除算法**

分为“Mark”和“Sweep”两个阶段，第一个阶段标记出所有不需要回收的对象，第二阶段回收掉这些对象。

缺点就是标记和清除两个过程的效率都不高，容易产生内存碎片。

**复制算法**

就是解决内存碎片的问题，当这一块的内存使用完毕之后，将还存活的对象复制到另外一半去，然后再把使用的空间进行清除。

缺点就是占用的内存会比较大，同时如果存活对象数量比较大，复制性能会变得比较差。

**标记-整理算法**

分为“Mark”和“arrange”两个阶段，标记的阶段和第一个算法是相同的，但是第二步其实就是类似于双指针来覆盖原先队列一样，进行整理。

缺点就是整理的过程也涉及到对象的移动，效率不高。

**分代收集算法**

根据对象存活周期的不同将对象进行分代，一半将Java堆分为新生代和老年代，这样我们可以根据各个代的特性不同选择合适的垃圾回收算法。

比如新生代可以用复制算法，老年代可以用标记-清除和标记-整理算法。
